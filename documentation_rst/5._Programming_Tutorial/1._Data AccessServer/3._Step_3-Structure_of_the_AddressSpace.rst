**Step 3 - Structure of the AddressSpace**
------------------------------------------

This section describes the structure of the object tree which is used by
the OPC Toolkit to process the OPC Client queries. The address space
contains all process values that are supported by the server.

Since we want the OPC Server of this tutorial to demonstrate two
different mechanisms of interfacing the I/O with the devices, you have
to add an extra AddressSpaceElement in the server’s address space. The
existing one has the IO mode set on POOL but you will create another one
that has the IO mode set on REPORT.

The tutorial server will support two process values: “Random value poll”
and “Random value report”. Both deliver a value randomly generated.

Adding the second AddressSpaceelment in the address space can be done
with the code written below (the bolded lines is what needs to be added
the other lines remained unchanged):

::

   long OpcServer::buildAddressSpace(void)
   {
       MyCreator* creator = (MyCreator*)getApp()->getCreator();
       tstring aName;

       // DA
       DaAddressSpaceRoot* daRoot = getApp()->getDaAddressSpaceRoot();

       m_pDaSimulationElement = (MyDaAddressSpaceElement*)creator->createMyDaAddressSpaceElement();
       aName = tstring(_T("Simulation"));
       m_pDaSimulationElement->setName(aName);
       m_pDaSimulationElement->setAccessRights(EnumAccessRights_READWRITEABLE);
       m_pDaSimulationElement->setDatatype(VT_I4);
       m_pDaSimulationElement->setIoMode(EnumIoMode_POLL);
       daRoot->addChild(m_pDaSimulationElement);

       DateTime now;
       Variant aVariant(rand());
       ValueQT value(aVariant, EnumQuality_GOOD, now);
       m_pDaSimulationElement->valueChanged(value);

       DaProperty* newProperty = new DaProperty();
       newProperty->setId(EnumPropertyId_ITEM_DESCRIPTION);
       tstring propName(_T("Description"));
       newProperty->setName(propName);
       tstring propDescription(_T("Element Description"));
       newProperty->setDescription(propDescription);
       newProperty->setItemId(propName);
       newProperty->setDatatype(VT_BSTR);
       newProperty->setAccessRights(EnumAccessRights_READABLE);

       m_pDaSimulationElement->addProperty(newProperty);
       m_reportSimulationElement = (MyDaAddressSpaceElement*)creator->createMyDaAddressSpaceElement();
       aName = tstring(_T("Random value report"));
       m_reportSimulationElement->setName(aName);
       m_reportSimulationElement->setAccessRights(EnumAccessRights_READABLE);
       m_reportSimulationElement->setDatatype(VT_I4);
       m_reportSimulationElement->setIoMode(EnumIoMode_REPORT);
       daRoot->addChild(m_reportSimulationElement);

       return S_OK;
   } // end buildAddressSpace

In the code above change the name of the m_pDaSimulationElement. Its new
name will be “Random value poll”. So please replace the following line
in the **buildAddressSpace** method:

::

   aName = tstring(_T("Simulation"));

with this line:

::

   aName = tstring(_T("Random value poll"));

As you can see, a new AddressSpaceElement was introduced. It is called
**m_reportSimulationElement**. You must define it in the **OpcServer.h**
file and initialize it in the constructor of the **OpcServer** class.

::

   //OpcServer.h
   private:
       ShutdownRequestHandler m_ShutdownRequest;
       MyDaAddressSpaceElement* m_pDaSimulationElement;
       MyDaAddressSpaceElement* m_reportSimulationElement;

   //OpcServer.cpp 
       OpcServer::OpcServer(void)
       { 
           m_pDaSimulationElement = NULL;
           m_reportSimulationElement = NULL;
        } // end constructor

Next you will be shown how you can add properties to the newly created
AddressSpaceElement. They can then be queried by an OPC Client later on.
To do this, you have to add the following lines in the method above:

::

   long OpcServer::buildAddressSpace(void)
   {
       MyCreator* creator = (MyCreator*)getApp()->getCreator();
       tstring aName;

       // DA
       DaAddressSpaceRoot* daRoot = getApp()->getDaAddressSpaceRoot();

       m_pDaSimulationElement = (MyDaAddressSpaceElement*)creator->createMyDaAddressSpaceElement();
       aName = tstring(_T("Random value poll"));
       m_pDaSimulationElement->setName(aName);
       m_pDaSimulationElement->setAccessRights(EnumAccessRights_READABLE);
       m_pDaSimulationElement->setDatatype(VT_I4);
       m_pDaSimulationElement->setIoMode(EnumIoMode_POLL);
       daRoot->addChild(m_pDaSimulationElement);

       DaProperty* newProperty = new DaProperty();
       newProperty->setId(EnumPropertyId_ITEM_DESCRIPTION);
       tstring propName(_T("Description"));
       newProperty->setName(propName);
       tstring propDescription(_T("Element Description"));
       newProperty->setDescription(propDescription);
       newProperty->setItemId(propName);
       newProperty->setDatatype(VT_BSTR);
       newProperty->setAccessRights(EnumAccessRights_READABLE);
       m_pDaSimulationElement->addProperty(newProperty);

       m_reportSimulationElement = (MyDaAddressSpaceElement*)creator->createMyDaAddressSpaceElement();
       aName = tstring(_T("Random value report"));
       m_reportSimulationElement->setName(aName);
       m_reportSimulationElement->setAccessRights(EnumAccessRights_READABLE);
       m_reportSimulationElement->setDatatype(VT_I4);
       m_reportSimulationElement->setIoMode(EnumIoMode_REPORT);
       daRoot->addChild(m_reportSimulationElement);
       DaProperty* secondProperty = new DaProperty();
       secondProperty->setId(EnumPropertyId_ITEM_DESCRIPTION); propName =
       _T("Description"); secondProperty->setName(propName); propDescription =
       _T("Element Description");
       secondProperty->setDescription(propDescription);
       secondProperty->setItemId(propName); secondProperty->setDatatype(VT_I2);
       secondProperty->setAccessRights(EnumAccessRights_READABLE);
       m_reportSimulationElement->addProperty(secondProperty);

       return S_OK; 
   } // end buildAddressSpace

You have now reached the end of the third step: the method that creates
the server’s adress space is now implemented. Next you have to use it.
For this, go to the \**_tmain*\* function and replace the following
code:

::

   // Start the OPC server's I/O internal mechanism
   if (SUCCEEDED(pServer->start()))
       {    
           // declare the namespaces built and the server ready for clients to connect        
           pServer->ready();
       }

with this one:

::

   // Start the OPC server's I/O internal mechanism
   if (SUCCEEDED(pServer->start()))
   {
       // build the addressSpace
       pServer->buildAddressSpace();
       // declare the namespaces built and the server ready for clients to connect 
       pServer->ready(); 
   }

After you have compiled the server, you can access it with an OPC Data
Access Client.

You can now browse the address space of the OPC Server and receive the
names of the created AddressSpaceElements. The figure below shows the
server’s address space in the Softing OPC Demo Client.

Bild
====
