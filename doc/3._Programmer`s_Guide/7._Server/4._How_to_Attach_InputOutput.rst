**How to Attach Input/Output**
------------------------------

Mechanism for Updating the DA Address Space Elements Values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The OPC Specification requires that the OPC DA Servers constantly check
whether the values of the OPC DA Items added to active OPC DA Client
groups have changed within the group’s update rate period. Since all the
operations inside an OPC DA Server are transaction-based, the
subscription monitoring operation is an internal cyclic read operation.

The Softing OPC DA Server Toolkit implements four (4) different
mechanisms for updating the DA Item values. The mechanism employed by
the Softing OPC Toolkit CORE depends on the **EnumIoMode** used when the
OPC DA Item is created in the OPC DA Server’s namespace.

Depending on the chosen OPC DA Item I/O mode, the Softing OPC Toolkit
CORE might invoke various callbacks for retrieving the OPC DA Item
values from the Vendor application. Likewise, for certain I/O modes no
callbacks will be invoked at all.

**Poll**

The DA Address Space Element value is actively polled from the Vendor DA
server application through the **DaTransaction HandleReadRequests**
callback each time a device read, an internal cyclic subscription read
or a readMaxAge with unsuitable cache age is performed. Internal Toolkit
CORE cache handles eligible readMaxAge requests and internal cyclic
subscription read operations.

**Poll Own Cache**

Very similar to the **Poll** I/O mode but without internal Toolkit CORE
caching. The DA Item’s value is actively polled by the Softing OPC
Toolkit CORE through the **DaTransaction HandleReadRequests** callback
and the DA Element’s cache value is also polled by the Toolkit CORE
through the **DaAddressSpaceElement QueryCacheValue** callback.

**Report**

The DA Address Space Element value is never polled from the Vendor DA
server application. The Softing OPC Toolkit enforces an entirely passive
approach with respect to device, cache or cyclic reads.

**Report Cyclic**

The Softing OPC Toolkit CORE will have almost the same behaviour as for
the Report I/O mode. The difference is that the Toolkit CORE will invoke
the DaTransaction HandleReadRequests callback if a direct item read is
performed by any of the connected OPC DA Clients.

For each address space element which stores the process value the I/O
type must be specified. This way the Softing OPC Toolkit knows how to
handle the read requests for each DA Address Space Element.

Within a single OPC DA Server, any I/O mode combination can be used
without causing any conflict. The I/O mode is per DA Address Space
Element.

Regardless of the DA Address Space Element’s I/O mode, each DA Item
write operation is sent to the Vendor DA server application through the
**DaTransaction HandleWriteRequests** callback.

Updating multiple DA Address Space Elements values for which issuing the
**DaAddressSpaceElement ValueChanged** method is relevant may be
performed by calling **DaAddressSpaceRoot ValuesChanged** method.

Note
~~~~

::

   All the DA read requests received within a transaction must be completed. The requests that cannot be resolved 
   during the read cycle must be completed with the quality: OPC_QUALITY_LAST_USABLE.

.. _note-1:

Note
~~~~

::

   It is recommended that no time-consuming operations are to be carried inside the DaTransaction 
   HandleReadRequests, DaTransaction HandleWriteRequests and DaAddressSpaceElement
   QueryCacheValue callbacks (as well as inside other TK callbacks). The threads on which these callbacks are 
   executed belong to the Toolkit CORE and the execution of various internal operations (sending diverse responses, 
   issuing callbacks towards connected DA Clients etc) running on other internal TK CORE threads is blocked until 
   more operations are internally conducted on these "donated threads" after the callbacks have returned.

Poll
~~~~

The Softing OPC Toolkit CORE implements an active polling mechanism for
reading the subscribed DA Items values.

The DA Address Space Element value is actively polled from the Vendor DA
server application through the **DaTransaction HandleReadRequests**
callback.

Device read operations will be normally delivered to the Vendor DA
server application through the **DaTransaction handleReadRequests**
callback.

When the subscription update rate period expires but the Vendor DA
server application did not provide any new values for the subscribed DA
Items with a Poll I/O mode (by calling the **DaItem’s ValueChanged**
method), the Toolkit CORE will actively read the values of all address
space elements from the device issuing a **DaTransaction
HandleReadRequests** callback for the DA Items which were not updated by
the Vendor server application during the current subscription update
rate period (during the current cyclic read transaction interval).

Internal cache mechanism is employed inside the Toolkit CORE which will
handle the eligible readMaxAge operations, whether the DA Item value was
reported (through **DaItem ValueChanged** method) or it was polled by
the Toolkit CORE (through **DaTransaction HandleReadRequests**
callback). ### Note

::

   The **Poll** Address Space Element I/O mode is a general-purpose I/O mode which is recommended to be used for 
   most of the items in the OPC DA Server namespace. The data points corresponding to DA Items created with Poll 
   I/O mode should support device read on request.

The following code snippet shows how to create a DA Address Space
Element with **Poll** I/O mode and the recommended methods that can be
called, respectively callbacks which need to be implemented in the
Vendor server application:

C
~

::

   // Following classes are derived from the Softing OPC Toolkit base classes:
   // ------------------------------------------------------------------------
   public class MyCreator : Creator { ... }
   public class MyDaAddressSpaceElement : DaAddressSpaceElement { ... }
   public class MyRequest : DaRequest { ... }
   public class MyTransaction : DaTransaction { ... }

   // Additional classes that are used by this sample (should be implemented in Vendor DA server application):
   // --------------------------------------------------------------------------------------------------------
   public class SomeDevice { ... } // this class is irrelevant of the item I/O mode; singleton implementation

   // Creating the DA Address Space Element and adding it to the root node:
   // ---------------------------------------------------------------------
   MyCreator myCreator = (MyCreator)Application.Instance.Creator;
   DaAddressSpaceRoot daRootNode = Application.Instance.DaAddressSpaceRoot;
   MyDaAddressSpaceElement daAddressSpaceElement = (MyDaAddressSpaceElement)myCreator.CreateMyDaAddressSpaceElement();
   daAddressSpaceElement.Name = "poll_io_mode_element_name";
   daAddressSpaceElement.AccessRights = EnumAccessRights.READWRITEABLE;
   daAddressSpaceElement.Datatype = typeof(System.Int32);
   daAddressSpaceElement.IoMode = EnumIoMode.POLL; // Poll I/O mode
   daRootNode.AddChild(daAddressSpaceElement);
   daAddressSpaceElement.ValueChanged(new ValueQT(0, EnumQuality.BAD_WAITING_FOR_INITIAL_DATA, DateTime.Now));

   // Reporting item values to the Toolkit CORE is allowed:
   // -----------------------------------------------------
   Int32 deviceValue = SomeDevice.Instance.SlowReadValue();
   daAddressSpaceElement.ValueChanged(new ValueQT(deviceValue, EnumQuality.GOOD, DateTime.Now));

   // Handling the Softing OPC Toolkit CORE active polling mechanism:
   // ---------------------------------------------------------------
   public class MyTransaction : DaTransaction
   {
     ...

     // Note: This code sample handles the FastDeviceRead inside the callback. Slow device operations should
     //       not be handled inside the TK callback threads.
     public override int HandleReadRequests()
     {
       lock(m_requestList.SyncRoot)
       {
         foreach (MyRequest daReadRequest in m_requestList)
         {
           if (daReadRequest.ProgressRequestState(EnumRequestState.PENDING, EnumRequestState.INPROGRESS))
           {
             MyDaAddressSpaceElement daAddressSpaceElement = daReadRequest.AddressSpaceElement as MyDaAddressSpaceElement;
             daReadRequest.Result = EnumResultCode.E_FAIL;
             if (daAddressSpaceElement != null)
             {
               if (daReadRequest.PropertyId == 0)
               {
                 Int32 deviceValue = 0;
                 if (SomeDevice.Instance.CanFastReadValue(ref deviceValue))
                 {
                   daReadRequest.Result = EnumResultCode.S_OK;
                   daReadRequest.Value = new ValueQT(deviceValue, EnumQuality.GOOD, DateTime.Now);
                 }
                 else
                 {
                   ValueQT cacheValue = null;
                   daReadRequest.Result = (EnumResultCode)daAddressSpaceElement.GetCacheValue(ref cacheValue);
                   if (ResultCode.SUCCEEDED(daReadRequest.Result))
                   {
                     EnumQuality cacheQuality = daReadRequest.Value.Quality;
                     if (cacheQuality != EnumQuality.BAD_WAITING_FOR_INITIAL_DATA)
                     {
                       cacheQuality = EnumQuality.UNCERTAIN_LAST_USABLE;
                     }
                     daReadRequest.Value = new ValueQT(cacheValue.Data, cacheQuality, cacheValue.TimeStamp);
                   }
                 }
               }
             }
             daReadRequest.Complete();
           }
         }
       }
       return (int)EnumResultCode.S_OK;
     }

     // Note: This code sample handles the FastDeviceWrite inside the callback. Slow device operations should
     //       not be handled on the TK callback threads.
     public override int HandleWriteRequests()
     {
       lock(m_requestList.SyncRoot)
       {
         foreach (MyRequest daWriteRequest in m_requestList)
         {
           if (daWriteRequest.ProgressRequestState(EnumRequestState.PENDING, EnumRequestState.INPROGRESS))
           {
             MyDaAddressSpaceElement daAddressSpaceElement = daWriteRequest.AddressSpaceElement as MyDaAddressSpaceElement;
             daWriteRequest.Result = EnumResultCode.E_FAIL;
             if (daAddressSpaceElement != null)
             {
               if (daWriteRequest.PropertyId == 0)
               {
                 if (SomeDevice.Instance.CanFastWriteValue(daAddressSpaceElement, daWriteRequest.Value))
                 {
                   daWriteRequest.Result = EnumResultCode.S_OK;
                 }
               }
             }
             daWriteRequest.Complete();
           }
         }
       }
       return (int)EnumResultCode.S_OK;
     }

     ...
   }

Poll Own Cache
~~~~~~~~~~~~~~

The Softing OPC Toolkit CORE will employ the same active value polling
mechanism as for the **Poll** I/O mode, but with a slight flavour
change: the Toolkit CORE will not employ any caching mechanism for the
values provided by the Vendor DA server application.

Calling the **DaItem’s ValueChanged** method will therefore have no
effect since internal caching is entirely disabled inside the Toolkit
CORE for items with Poll I/O mode.

The DA Element’s cache value is polled from the Vendor DA server
application through the **DaAddressSpaceElement QueryCacheValue**
callback.

The DA Address Space Element value is actively polled from the Vendor DA
server application through the **DaTransaction HandleReadRequests**
callback.

Device read operations will be normally delivered to the Vendor DA
server application through the **DaTransaction HandleReadRequests**
callback.

Each time a cache read is performed or when the cache eligibility needs
to be checked, the Softing OPC Toolkit CORE will invoke the
**DaAddressSpaceElement QueryCacheValue** callback for reading (parts
of) the DA Element’s cache value. Keeping the cache value is the sole
responsibility of the Vendor DA server application.

The Softing OPC Toolkit CORE will only issue the **DaTransaction
HandleReadRequests** callback if the cache value has not changed during
the current cyclic read transaction interval, if a device read is
requested or if a readMaxAge is requested and the requested cache age
renders the DA Item’s cache value provided by the Vendor DA server
application as not suitable for the current request. The Vendor DA
server application should update its cache value each time a device read
is performed. ### Note

::

   The **Poll Own Cache** Address Space Element I/O mode is a special I/O mode which is recommended to be used 
   by the Vendor DA server application if more items from the DA namespace represent the same data point. 
   Significant cutbacks in memory consumption and lower device bandwidth requirement can therefore be achieved 
   very easily.

The following code snippet shows how to create a DA Address Space
Element with **Poll Own Cache** I/O mode and the recommended methods
that can be called, respectively callbacks which need to be implemented
in the Vendor server application: ### C#

::

   // Following classes are derived from the Softing OPC Toolkit base classes:
   // ------------------------------------------------------------------------
   public class MyCreator : Creator { ... }
   public class MyDaAddressSpaceElement : DaAddressSpaceElement { ... }
   public class MyRequest : DaRequest { ... }
   public class MyTransaction : DaTransaction { ... }

   // Additional classes that are used by this sample (should be implemented in Vendor DA server application):
   // --------------------------------------------------------------------------------------------------------
   public class MyCacheManager { ... } // singleton implementation
   public class MyWorkerThreads { ... } // this class is irrelevant of the item I/O mode; singleton implementation
   public class SomeDevice { ... } // this class is irrelevant of the item I/O mode; singleton implementation

   // Creating the DA Address Space Element and adding it to the root node:
   // ---------------------------------------------------------------------
   MyCreator myCreator = (MyCreator)Application.Instance.Creator;
   DaAddressSpaceRoot daRootNode = Application.Instance.DaAddressSpaceRoot;
   MyDaAddressSpaceElement daAddressSpaceElement = (MyDaAddressSpaceElement)myCreator.CreateMyDaAddressSpaceElement();
   daAddressSpaceElement.Name = "poll_own_cache_io_mode_element_name";
   daAddressSpaceElement.AccessRights = EnumAccessRights.READWRITEABLE;
   daAddressSpaceElement.Datatype = typeof(System.Int32);
   daAddressSpaceElement.IoMode = EnumIoMode.POLL_OWNCACHE; // Poll Own Cache I/O mode
   daRootNode.AddChild(daAddressSpaceElement);
   MyCacheManager.Instance.SetMyCacheValue(daAddressSpaceElement, new ValueQT(0, EnumQuality.BAD_WAITING_FOR_INITIAL_DATA, DateTime.Now));

   // Reporting item values to the Toolkit CORE is irrelevant, values should be stored inside the Vendor DA server application's cache:
   // ---------------------------------------------------------------------------------------------------------------------------------
   Int32 deviceValue = SomeDevice.Instance.SlowReadValue();
   MyCacheManager.Instance.SetMyCacheValue(daAddressSpaceElement, new ValueQT(deviceValue, EnumQuality.GOOD, DateTime.Now));

   // Handling the Softing OPC Toolkit CORE active polling mechanism:
   // ---------------------------------------------------------------
   public class MyTransaction : DaTransaction
   {
     ...

     // Note: This code sample handles the FastDeviceRead inside the callback and slow device operations
     //       on a different thread.
     public override int HandleReadRequests()
     {
       bool requestHandled;
       lock(m_requestList.SyncRoot)
       {
         foreach (MyRequest daReadRequest in m_requestList)
         {
           requestHandled = true;
           if (daReadRequest.ProgressRequestState(EnumRequestState.PENDING, EnumRequestState.INPROGRESS))
           {
             MyDaAddressSpaceElement daAddressSpaceElement = daReadRequest.AddressSpaceElement as MyDaAddressSpaceElement;
             daReadRequest.Result = EnumResultCode.E_FAIL;
             if (daAddressSpaceElement != null)
             {
               if (daReadRequest.PropertyId == 0)
               {
                 Int32 deviceValue = 0;
                 if (SomeDevice.Instance.CanFastReadValue(ref deviceValue))
                 {
                   daReadRequest.Result = EnumResultCode.S_OK;
                   ValueQT newDeviceValue = new ValueQT(deviceValue, EnumQuality.GOOD, DateTime.Now);
                   MyCacheManager.Instance.SetMyCacheValue(daAddressSpaceElement, newDeviceValue);
                   daReadRequest.Value = newDeviceValue;
                 }
                 else
                 {
                   MyWorkerThreads.Instance.AddRequestToWorkQueue(daReadRequest);
                   requestHandled = false;
                 }
               }
             }
             if (requestHandled)
             {
               daReadRequest.Complete();
             }
           }
         }
       }
       return (int)EnumResultCode.S_OK;
     }

     // Note: This code sample handles the FastDeviceWrite inside the callback and slow device operations
     //       on a different thread.
     public override int HandleWriteRequests()
     {
       bool requestHandled;
       lock(m_requestList.SyncRoot)
       {
         foreach (MyRequest daWriteRequest in m_requestList)
         {
           requestHandled = true;
           if (daWriteRequest.ProgressRequestState(EnumRequestState.PENDING, EnumRequestState.INPROGRESS))
           {
             MyDaAddressSpaceElement daAddressSpaceElement = daWriteRequest.AddressSpaceElement as MyDaAddressSpaceElement;
             daWriteRequest.Result = EnumResultCode.E_FAIL;
             if (daAddressSpaceElement != null)
             {
               if (daWriteRequest.PropertyId == 0)
               {
                 if (SomeDevice.Instance.CanFastWriteValue(daAddressSpaceElement, daWriteRequest.Value))
                 {
                   MyCacheManager.Instance.SetMyCacheValue(daAddressSpaceElement, daWriteRequest.Value);
                   daWriteRequest.Result = EnumResultCode.S_OK;
                 }
                 else
                 {
                   MyWorkerThreads.Instance.AddRequestToWorkQueue(daWriteRequest);
                   requestHandled = false;
                 }
               }
             }
             if (requestHandled)
             {
               daWriteRequest.Complete();
             }
           }
         }
       }
       return (int)EnumResultCode.S_OK;
     }

     ...
   }

   // Handling the Softing OPC Toolkit CORE cache querying mechanism:
   // ---------------------------------------------------------------
   public class MyDaAddressSpaceElement : DaAddressSpaceElement
   {
     ...

     public override int QueryCacheValue(DaSession aSession, ref ValueQT aCacheValue)
     {
       if (MyCacheManager.Instance.CanGetMyCacheValue(daAddressSpaceElement, ref aCacheValue))
       {
         return (int)EnumResultCode.S_OK;
       }
       else
       {
         return EnumResultCode.E_FAIL;
       }
     }

     ...
   }

   // This class only executes slow device read and write operations on a different thread.
   public class MyWorkerThreads
   {
     ...

     void AddRequestToWorkQueue(DaRequest request)
     {
       lock (myRequestList.SyncRoot)
       {
         myRequestList.Add(request);
       }
     }

     void MyWorkerThreadEntryPoint()
     {
       MyRequest request = null;
       while (applicationNotStopped)
       {
         request = null;
         lock (myRequestList.SyncRoot)
         {
           if (myRequestList.Count > 0)
           {
             request = myRequestList[0] as MyRequest;
             myRequestList.RemoveAt(0);
           }
         }
         if (request != null)
         {
           MyDaAddressSpaceElement daAddressSpaceElement = request.AddressSpaceElement as MyDaAddressSpaceElement;
           if (daAddressSpaceElement != null)
           {
             if (request.TransactionType == EnumTransactionType.READ)
             {
               Int32 deviceValue = 0;
               if (SomeDevice.Instance.CanSlowReadValue(ref deviceValue))
               {
                 request.Result = EnumResultCode.S_OK;
                 ValueQT newDeviceValue = new ValueQT(deviceValue, EnumQuality.GOOD, DateTime.Now);
                 MyCacheManager.Instance.SetMyCacheValue(daAddressSpaceElement, newDeviceValue);
                 request.Value = newDeviceValue;
               }
               else
               {
                 ValueQT cacheValue = null;
                 if (MyCacheManager.Instance.CanGetMyCacheValue(daAddressSpaceElement, ref cacheValue))
                 {
                   request.Value = new ValueQT(cacheValue.Data, EnumQuality.UNCERTAIN_LAST_USABLE, cacheValue.TimeStamp);
                   request.Result = EnumResultCode.S_OK;
                 }
               }
             }
             else
             {
               if (SomeDevice.Instance.CanSlowWriteValue(daAddressSpaceElement, request.Value))
               {
                 MyCacheManager.Instance.SetMyCacheValue(daAddressSpaceElement, request.Value);
                 request.Result = EnumResultCode.S_OK;
               }
             }
           }
           request.Complete();
         }
         else
         {
           Thread.Sleep(10);
         }
       }
     }

     ...
   }

Report
~~~~~~

The Softing OPC Toolkit CORE will not poll any DA Item values from the
Vendor DA server application at all for DA Items with **Report** I/O
mode, but will rather use the latest value the Vendor DA server
application provided through the **DaAddressSpaceElement ValueChanged**
method call.

The Softing OPC Toolkit will use an internal cache mechanism to store
the value provided by the Vendor DA server application which is entirely
responsible for communicating the individual DA Item values to the
Toolkit CORE through the **DaItem ValueChanged** method.

No read callbacks will be invoked by the Softing OPC Toolkit CORE even
if device reads are performed by OPC DA Clients. The internal TK CORE
cache is exclusively used for such operations. ### Note

::

   The **Report** Address Space Element I/O mode is a special, entirely passive I/O mode which is recommended to 
   be used by the Vendor DA server application if device access mode is serial or if the device access times are very 
   high. Reporting the value of a DA Address Space Element is preferred to keeping many requests in waiting state 
   until the daisy-chained/slow devices may be interrogated.

The following code snippet shows how to create a DA Address Space
Element with **Report** I/O mode and the recommended methods that can be
called, respectively callbacks which need to be implemented in the
Vendor server application:

.. _c-1:

C
~

::

   // Following classes are derived from the Softing OPC Toolkit base classes:
   // ------------------------------------------------------------------------
   public class MyCreator : Creator { ... }
   public class MyDaAddressSpaceElement : DaAddressSpaceElement { ... }
   public class MyRequest : DaRequest { ... }
   public class MyTransaction : DaTransaction { ... }

   // Additional classes that are used by this sample (should be implemented in Vendor DA server application):
   // --------------------------------------------------------------------------------------------------------
   public class MyWorkerThreads { ... } // this class is irrelevant of the item I/O mode; singleton implementation
   public class SomeDevice { ... } // this class is irrelevant of the item I/O mode; singleton implementation

   // Creating the DA Address Space Element and adding it to the root node:
   // ---------------------------------------------------------------------
   MyCreator myCreator = (MyCreator)Application.Instance.Creator;
   DaAddressSpaceRoot daRootNode = Application.Instance.DaAddressSpaceRoot;
   MyDaAddressSpaceElement daAddressSpaceElement = (MyDaAddressSpaceElement)myCreator.CreateMyDaAddressSpaceElement();
   daAddressSpaceElement.Name = "report_io_mode_element_name";
   daAddressSpaceElement.AccessRights = EnumAccessRights.READWRITEABLE;
   daAddressSpaceElement.Datatype = typeof(System.Int32);
   daAddressSpaceElement.IoMode = EnumIoMode.REPORT; // Report I/O mode
   daRootNode.AddChild(daAddressSpaceElement);
   daAddressSpaceElement.ValueChanged(new ValueQT(0, EnumQuality.BAD_WAITING_FOR_INITIAL_DATA, DateTime.Now));

   // Reporting item values to the Toolkit CORE:
   // ------------------------------------------

   Int32 deviceValue = SomeDevice.Instance.SlowReadValue();
   daAddressSpaceElement.ValueChanged(new ValueQT(deviceValue, EnumQuality.GOOD, DateTime.Now));

   // Handling the Softing OPC Toolkit CORE writing mechanism:
   // --------------------------------------------------------
   public class MyTransaction : DaTransaction
   {
     ...

     // Note: This code sample handles the FastDeviceWrite inside the callback and slow device operations
     //       on a different thread.
     public override int HandleWriteRequests()
     {
       bool requestHandled;
       lock(m_requestList.SyncRoot)
       {
         foreach (MyRequest daWriteRequest in m_requestList)
         {
           requestHandled = true;
           if (daWriteRequest.ProgressRequestState(EnumRequestState.PENDING, EnumRequestState.INPROGRESS))
           {
             MyDaAddressSpaceElement daAddressSpaceElement = daWriteRequest.AddressSpaceElement as MyDaAddressSpaceElement;
             daWriteRequest.Result = EnumResultCode.E_FAIL;
             if (daAddressSpaceElement != null)
             {
               if (daWriteRequest.PropertyId == 0)
               {
                 if (SomeDevice.Instance.CanFastWriteValue(daAddressSpaceElement, daWriteRequest.Value))
                 {
                   daWriteRequest.Result = EnumResultCode.S_OK;
                 }
                 else
                 {
                   MyWorkerThreads.Instance.AddWriteRequestToWorkQueue(daWriteRequest);
                   requestHandled = false;
                 }
               }
             }
             if (requestHandled)
             {
               daWriteRequest.Complete();
             }
           }
         }
       }
       return (int)EnumResultCode.S_OK;
     }

     ...
   }

   // This class only executes slow device write operations on a different thread.
   public class MyWorkerThreads
   {
     ...

     void AddWriteRequestToWorkQueue(DaRequest writeRequest)
     {
       lock (myRequestList.SyncRoot)
       {
         myRequestList.Add(writeRequest);
       }
     }

     void MyWorkerThreadEntryPoint()
     {
       MyRequest writeRequest = null;
       while (applicationNotStopped)
       {
         writeRequest = null;
         lock (myRequestList.SyncRoot)
         {
           if (myRequestList.Count > 0)
           {
             writerequest = myRequestList[0] as MyRequest;
             myRequestList.RemoveAt(0);
           }
         }
         if (writeRequest != null)
         {
           MyDaAddressSpaceElement daAddressSpaceElement = writeRequest.AddressSpaceElement as MyDaAddressSpaceElement;
           if (daAddressSpaceElement != null)
           {
             if (writeRequest.TransactionType == EnumTransactionType.WRITE)
             {
               if (SomeDevice.Instance.CanSlowWriteValue(daAddressSpaceElement, writeRequest.Value))
               {
                 writeRequest.Result = EnumResultCode.S_OK;
               }
             }
           }
           writeRequest.Complete();
         }
         else
         {
           Thread.Sleep(10);
         }
       }
     }

     ...
   }

Report Cyclic
~~~~~~~~~~~~~

The Softing OPC Toolkit CORE behaviour for the **Report Cyclic** I/O
mode is very similar to the Report I/O mode, with the sole difference
that for any device read request or for any readMaxAge request for which
the cache value does not qualify, the **DaTransaction
HandleReadRequests** callback will be invoked in the Vendor DA Server
application.

The Softing OPC Toolkit engages an internal cache mechanism to store the
value provided by the Vendor DA server application through the **DaItem
ValueChanged** method or when **DaTransaction HandleReadRequests**
callback is invoked. The cache value will be used for all the cyclic
subscription reads and also for readMaxAge requests, should the cache
age satisfy the request.

.. _note-2:

Note
~~~~

::

   The **Report Cyclic** Address Space Element I/O mode is another special, almost passive I/O mode which is 
   recommended to be used by the Vendor DA server application for data points originating from slow devices but 
   where device reads should be conducted on request. It is best for the OPC DA Clients to only issue asynchronous 
   device read (and write) operations for serial devices or devices with large access times.

The following code snippet shows how to create a DA Address Space
Element with **Report Cyclic** I/O mode and the recommended methods that
can be called, respectively callbacks which need to be implemented in
the Vendor server application:

.. _c-2:

C
~

::

   // Following classes are derived from the Softing OPC Toolkit base classes:
   // ------------------------------------------------------------------------
   public class MyCreator : Creator { ... }
   public class MyDaAddressSpaceElement : DaAddressSpaceElement { ... }
   public class MyRequest : DaRequest { ... }
   public class MyTransaction : DaTransaction { ... }

   // Additional classes that are used by this sample (should be implemented in Vendor DA server application):
   // --------------------------------------------------------------------------------------------------------
   public class MyWorkerThreads { ... } // this class is irrelevant of the item I/O mode; singleton implementation
   public class SomeDevice { ... } // this class is irrelevant of the item I/O mode; singleton implementation

   // Creating the DA Address Space Element and adding it to the root node:
   // ---------------------------------------------------------------------
   MyCreator myCreator = (MyCreator)Application.Instance.Creator;
   DaAddressSpaceRoot daRootNode = Application.Instance.DaAddressSpaceRoot;
   MyDaAddressSpaceElement daAddressSpaceElement = (MyDaAddressSpaceElement)myCreator.CreateMyDaAddressSpaceElement();
   daAddressSpaceElement.Name = "report_cyclic_io_mode_element_name";
   daAddressSpaceElement.AccessRights = EnumAccessRights.READWRITEABLE;
   daAddressSpaceElement.Datatype = typeof(System.Int32);
   daAddressSpaceElement.IoMode = EnumIoMode.REPORT_CYCLIC; // Report Cyclic I/O mode
   daRootNode.AddChild(daAddressSpaceElement);
   daAddressSpaceElement.ValueChanged(new ValueQT(0, EnumQuality.BAD_WAITING_FOR_INITIAL_DATA, DateTime.Now));

   // Reporting item values to the Toolkit CORE is irrelevant, values should be stored inside the Vendor DA server application's cache:
   // ------------------------------------------------------------------------------------------------------------------------------
   Int32 deviceValue = SomeDevice.Instance.SlowReadValue();
   daAddressSpaceElement.ValueChanged(new ValueQT(deviceValue, EnumQuality.GOOD, DateTime.Now));

   // Handling the Softing OPC Toolkit CORE active polling mechanism:
   // ---------------------------------------------------------------
   public class MyTransaction : DaTransaction
   {
     ...

     // Note: This code sample only adds the received read requests
     //       to the worker thread's queue.
     public override int HandleReadRequests()
     {
       lock(m_requestList.SyncRoot)
       {
         foreach (MyRequest daReadRequest in m_requestList)
         {
           MyWorkerThreads.Instance.AddRequestToWorkQueue(daReadRequest);
         }
       }
       return (int)EnumResultCode.S_OK;
     }

     // Note: This code sample only adds the received write requests
     //       to the worker thread's queue.
     public override int HandleWriteRequests()
     {
       lock(m_requestList.SyncRoot)
       {
         foreach (MyRequest daWriteRequest in m_requestList)
         {
           MyWorkerThreads.Instance.AddRequestToWorkQueue(daWriteRequest);
         }
       }
       return (int)EnumResultCode.S_OK;
     }

     ...
   }

   // This class only executes device read and write operations on a different thread.
   public class MyWorkerThreads
   {
     ...

     void AddRequestToWorkQueue(DaRequest request)
     {
       lock (myRequestList.SyncRoot)
       {
         myRequestList.Add(request);
       }
     }

     void MyWorkerThreadEntryPoint()
     {
       MyRequest request = null;
       while (applicationNotStopped)
       {
         request = null;
         lock (myRequestList.SyncRoot)
         {
           if (myRequestList.Count > 0)
           {
             request = myRequestList[0] as MyRequest;
             myRequestList.RemoveAt(0);
           }
         }
         if (request != null)
         {
           MyDaAddressSpaceElement daAddressSpaceElement = request.AddressSpaceElement as MyDaAddressSpaceElement;
           if (request.ProgressRequestState(EnumRequestState.PENDING, EnumRequestState.INPROGRESS))
           {
             MyDaAddressSpaceElement daAddressSpaceElement = request.AddressSpaceElement as MyDaAddressSpaceElement;
             request.Result = EnumResultCode.E_FAIL;
             if (daAddressSpaceElement != null)
             {
               if (request.TransactionType == EnumTransactionType.READ)
               {
                 if (request.PropertyId == 0)
                 {
                   Int32 deviceValue = 0;
                   if (SomeDevice.Instance.CanReadValue(ref deviceValue))
                   {
                     request.Result = EnumResultCode.S_OK;
                     ValueQT newDeviceValue = new ValueQT(deviceValue, EnumQuality.GOOD, DateTime.Now);
                     request.Value = newDeviceValue;
                   }
                 }
               }
               else
               {
                 if (SomeDevice.Instance.CanWriteValue(daAddressSpaceElement, request.Value))
                 {
                   request.Result = EnumResultCode.S_OK;
                 }
               }
             }
             request.Complete();
           }
         }
         else
         {
           Thread.Sleep(10);
         }
       }
     }

     ...
   }
