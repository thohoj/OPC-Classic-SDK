**DCOM**
--------

OPC (OLE for Process Control) is based on Microsoft’s DCOM technology.
An explanation of design and implementation aspects for OPC is not
possible without first conveying the fundamental principles of this
technology.

Two main objectives were the catalyst for developing DCOM:

-  To be able to process documents having different information
   representation formats and
-  To ensure binary compatibility between software components (backwards
   compatibility, autonomous upgrades, co-existence of older and newer
   software).

These efforts led to the definition of the Component Object Model (COM)
by Microsoft in the first half of the last decade. The aim of this model
is to guarantee binary compatibility between software components.

Interaction between the components is based on the access to methods
grouped in interfaces. A component object contains several interfaces
encapsulating the access to the object. In the remainder of this
chapter, the term “object” is used as a synonym for “component object”.

COM defines the following:

-  the externally accessible binary structure of a COM object
-  a methodology of how an object can be queried during runtime as to
   whether it supports a certain interface or not
-  a procedure how the life cycle of objects is controlled. A reference
   counter is used for this purpose which is incremented when an
   interface is used for the first time and decremented upon release.
   The counter switches to zero if all interfaces are released. This
   indicates that the object is no longer used and allowed to terminate
   itself.
-  how interactions can be performed between objects beyond process
   boundaries. This is necessary because pointers to interfaces and
   method parameters are only valid within a process space.
-  the procedure for identifying and loading objects

DCOM (Distributed COM) has existed ever since Windows NT 4.0 came into
existence, whereby DCOM contains the following new aspects as compared
to COM:

-  distribution of resources
-  security
-  various threading models

Two important questions are: how does the client get the first pointer
to the interface of a server? How does the client launch a server?

Bild
====

The client calls the function CoGetClassObject(). This function is
provided by the operating system in the DLL ole32. The following
parameters, among others, are transferred to the function:

-  the CLSID of the server to be launched. This CLSID is unique
   world-wide and is specified by the implementing party of the server.
-  pServerInfo. This parameter obtained meaning only after the
   introduction of DCOM. This structure contains the following
   components:

   -  the name of the remote computer on which the server is to be
      launched.
   -  a structure containing authorization information.

-  identifier of an Interface IClassFactory. The identifier has been
   specified by Microsoft and is therefore always the same. The reason
   is that the same functionality is provided every time.
-  memory space for the returned pointer to the Interface IClassFactory.

The executable file containing the server is referenced by a registry
entry. The COM runtime uses this entry to start the executable.
Localization is based on the CLSID and uses entries in the registry.
When the executable is started, a factory is created and the pointer to
the interface is returned.

The client now calls the method CreateInstance on Interface
IClassFactory and the factory creates the server. This two-stage process
enables the start of servers to be adapted to different requirements.
The requested interface pointer is returned as a result of the server
creation. Now different methods can be called, e.g. QueryInterface or
other methods.

Three versions of an OPC Server can be implemented.

-  DLL/ InProc-Server:

   In this case, it operates in the process space of the OPC Client.
   This is entirely transparent for the OPC Client since COM loads the
   DLL (and unloads it). Particularities are to be taken into account
   when remotely accessing the DLL.

-  Local and remote server(OutProc Server):

   The OPC Server operates as an autonomous program. It is started from
   the OPC Client whenever it is used. Most OPC Servers have been
   implemented as local or remote servers up to now. The server can be
   located either on the same computer as the client or on another
   computer.

-  Windows NT Service:

   A service is immediately started upon booting of the operating system
   and therefore also runs without user log-in. Normally, a service does
   not have a user interface. If a user interface is required it must
   run independently from the service. An OPC Server may run as service
   only under Windows XP / Windows 2000 / Windows Vista / Windows 7 and
   related server editions.

These statements apply to all COM/DCOM Servers.

Security aspects are of supreme importance in the distribution of
components. It must be guaranteed that the data exchange between OPC
Servers and OPC Clients only occurs between the components intended for
this purpose.

A client launches a process on a remote computer. It must be authorized
for this purpose. It must again be able to perform certain actions for
this process. At the same time, however, the client must also be sure
that the server only performs actions which are appropriate to the
client. The server can impersonate the client for this purpose.

The safety requirements are bi-directional.

Security can be achieved in two ways:

-  Information on security aspects is contained in the registry. This
   works for components that are either not aware of security mechanisms
   or do not use them. It can be changed using DCOMcnfg. This is known
   as declarative security.
-  Through the introduction of DCOM, a series of program-specific
   methods are available with which widely varying security features can
   be achieved. This is known as programmatic security.
